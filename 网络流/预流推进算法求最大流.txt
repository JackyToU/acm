发信人: violinist (巷战狙击手), 信区: Algorithm
标  题: 预流推进算法求最大流[转]
发信站: 日月光华 (2007年05月27日11:37:30 星期天)


预流推进算法求最大流[转]


传统的最大流标记算法通过寻找可改进路的方法不断将新的流量从源点(s)引向汇点(t)。


　　预流推进(Preflow-Push)的思想与传统方法不同在于最初给源点加以最大流量，不断
将这个流量(Preflow)向汇点推进，在过程中将无法到达源点的流量返回至源点，这种思想
相对于传统的方法更为直观，偏向于生活中的管道流量模型的自发性调整。



　　对预流的定义如下，如果在网络中存在一个内点(internal node)v，满足

ΣwPwv > ΣuPvu

　　由此引出一个过流(excess flow)的定义，

ex(v) = ΣwPwv - ΣuPvu

　　显然当找到最大流的时候，对于所有的内点v，

ex(v) = 0

　　对于一个存在预流的网络，必定存在一个内点v，其ex(v) > 0，且有Pvw < Cvw或者P
wv > 0，此时可以将过流通过为饱和的正向边流向t，或者将无法推进的流量反推回源点。
这样可以使ex(v) = 0，满足达到大流的条件。

　　但是这里存在一个明显的问题，就是如何确定应该向前流还是返回，或者，当情况恶
劣时将会出现无限的环流，即某一过流循环在一个闭合环形回路中流动，造成死循环。


　　对于这个问题，该算法的解决方法是加入一个标签λ，规定过流只能沿着满足λ(a)>λ(b)的弧ab流动。
通过标签控制流的方向，能使过流总是努力向汇点前进，在最后才选
择返回，当然这需要一个初始设定，即λ(s) = |V(G)|, λ(t) = 0, λ(v) = 0 ( v is
internal node )。

　　引入两个定义，可行边(available edge)与可接纳流(admissible edge)，可行边定义
为

e ∈{ ab ∈E(G) | Pab < Cab or Pba > 0 }

　　可接纳边的定义

e ∈{ ab | ab is an available edge, λ(a) = λ(b) + 1 }

　　个人认为可接纳边的存在是对λ定义的一个补充，λ实际上体现了节点上的"势"，势
推动载流子前进。由于过流的存在，节点上的载流子不断积聚却因为节点的势小于相邻节
点而无法流出，可以设想节点a最初时满足

λ(a) <= λ(b) (b | ab,ba ∈E(G))

　　载流子的积聚，使势逐渐增加，当出现λ(a)>λ(b)的情况时，积聚的流体义无反顾地
流向b，此时，即满足

λ(a) = λ(b) + 1

　　这种积聚的过程，就是对λ的重编号(relabel)过程，这也是过流前进的动力。

　　当然，我们还需要一些初始规则启动整个算法。通过λ的初始设定，给整个网络加上
了一个场，使流量定向地由源流向汇，此时只需要给网络加上最初的流体即可。此时只需
要给所有从源点发出的弧ab加上大小为Cab的流即可，此时所有存在从源连入的弧的节点v
将满足

ex(v) = Csv


　　至此，预流推进的条件与规则都已完善，一下为算法的流程。

　　对一个活动节点的处理过程如下：

1.选取一个活动节点(active node)v，即满足ex(v)>0的节点；
2.找到一个从v发出的可接纳边；
3.将v上的过流进可能通过这个可接纳边流出；
4.重复步骤2与步骤3，当ex(v)=0或者找不到可接纳边时转向步骤5
5.如果ex(v)>0却找不到可接纳边，则令λ(v) = min {λ(a) + 1 | va is an available
 edge}，并返回步骤2。(这是流体积聚的过程)
6.如果ex(v)=0则该对节点的处理过程完毕。(所有积聚的流体都流出)


    预流推进的驱动过程：

1.初始化各节点状态，加上最初的预流，给网络加压
2.如果网络中存在活动节点，则处理这个活动节点



--
※ 来源:・日月光华 bbs.fudan.edu.cn・HTTP [FROM: 211.65.100.130]                                                        

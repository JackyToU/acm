(*
   Data Importing Unit
   for problem FrogGame.
*)

{$D-,L-,Y-}
  {protect the private part of this unit
     from being detected by users' selecting Search|Unit menu }
{$A+,B-,E-,F-,G+,I-,N-,O-,P-,Q-,R-,S-,T-,V+,X+}
{$M 5120,0,10240}
  {gernerate smaller & faster code}

Unit Import;

Interface
 {open part for contestants}

Const MaxLines=80;
      MaxVisibility=80;
      LimitedV=5;

Type TColumn=Array[1..MaxLines]of char;

Var NoNew:boolean;

Procedure GetSettings(var vLines,vVis,vScr0,vScr1,vScr2:integer);
Procedure GetInitArea(var aCol:TColumn);
Procedure FrogJump(v:integer;var NewCol:TColumn);

Implementation
 {hidden part for contestants}

const
   {open for contestants:}
      fnTxt='FrogGame.txt';
      fnOpn='Result.txt'; {not generated by the user-program but this unit}
   {hidden for contestants:}
      fnIn ='FrogGame.in';
      fnOut='FrogGame.out'; {not generated by the user-program but this unit}

var f:text;
    OpenMode:boolean; {whether we are using FrogGame.txt/Result.txt}

    lines,cols,cols0,
    Vis {visibility} ,
    Goal0,Goal1,Goal2:integer; {3 kind of score}

    MaxV,Loc{current location of a column}:integer;
    Score:longint;

    area:array[1..MaxVisibility]of TColumn;
    pJump,pVis:integer; {pointers of loop-array}

procedure ReadAColumn(var col:TColumn);
{read a column from the testdata}
var i:integer;
begin
  for i:=1 to lines do read(f,col[i]);
  readln(f); inc(cols0);
end;

procedure BadCall;
{this is executed when the user program
 makes an illegal or invalid call}
begin
  close(f);assign(f,fnOut);
  erase(f); {prevent the contestants from changing the score}
  halt(1);
end;

procedure InitFile;
{process the data head}
var i,j:integer;
    col:TColumn;
    s:string;
begin
  assign(f,fnOut);erase(f);
  i:=ioresult;{clear the error flag}
  assign(f,fnIn);OpenMode:=false;
  reset(f);
  if ioresult<>0 then begin assign(f,fnTxt);reset(f);OpenMode:=true;end;
  if ioresult<>0 then runerror(2);
  readln(f,cols,lines);
  readln(f,vis);
  readln(f,goal0,goal1,goal2);

  pJump:=1;pVis:=0;cols0:=0;
  score:=0;MaxV:=1;loc:=(lines+1)div 2;
end;

procedure Done;
{write the game score and then terminate}
begin
  close(f);
  if openmode then assign(f,fnOpn) else assign(f,fnOut);rewrite(f);
  writeln(f,score);
  close(f);
  halt(0); {prevent the contestants from changing the score}
end;

Procedure GetSettings;
begin
  vlines:=lines;vVis:=Vis;
  vScr0:=Goal0;vScr1:=Goal1;vScr2:=Goal2;
end;

Procedure GetInitArea;
begin
  if cols0>=vis then exit;
  inc(pVis);
  readacolumn(area[pVis]);
  aCol:=area[pVis];
end;

Procedure FrogJump;
var i,j,l:integer;
    block:boolean;
begin
  if (cols0<vis)or(v>maxv)or(v<-maxv) then BadCall;
  inc(pJump);if pJump>vis then pJump:=(pJump-1) mod vis +1;
  inc(loc,v);inc(score,goal0);
  if (loc<1)or(loc>lines) then BadCall;
  case area[pJump,loc] of
    'b':BadCall;
    'g':inc(MaxV);
    'o':inc(score,goal1);
    'r':dec(score,goal2);
  end;

  NoNew:=true;
  if cols0<cols then
    begin
      inc(pVis);if pVis>vis then pVis:=(pVis-1) mod vis +1;
      readacolumn(area[pVis]);NewCol:=area[pVis];NoNew:=false;
    end;
  if pJump=pVis
    then Done {successfully corss the pool}
    else begin
      block:=true;l:=pJump+1;if l>vis then l:=(l-1) mod vis +1;
      for i:=loc-maxv to loc+maxv do
        if (i>0)and(i<=lines)and(area[l,i]<>'b')then
          begin block:=false;break;end;
      if block then Done; {no possible jump}
    end;
end;

Begin
  InitFile;
End.